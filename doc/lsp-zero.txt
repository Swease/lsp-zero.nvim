==============================================================================
*lsp-zero.txt*

A starting point to setup some lsp related features in neovim.

==============================================================================
Introduction                                                  *lsp-zero-intro*

The purpose of this plugin is to bundle all the "boilerplate code" needed
to have |nvim-cmp| (a popular autocompletion plugin) and the |LSP| client
working together.

==============================================================================
Quickstart                                               *lsp-zero-quickstart*

The fastest way to get started is by using a "preset" and immediately call
the |lsp-zero.setup()| function.
>lua
  local lsp = require('lsp-zero').preset({})

  lsp.extend_cmp()

  lsp.on_attach(function(client, bufnr)
    lsp.default_keymaps({buffer = bufnr})
  end)

  -- Replace the language servers listed here
  -- with the ones you have installed
  lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
With this configuration lsp-zero will create keymaps to take advantage of some
features like jump to definition, rename variables, etc. It will also setup
the basic features of the autocompletion plugin.

=============================================================================
autocomplete                                          *lsp-zero-autocomplete*

The plugin responsable for autocompletion is |nvim-cmp|. This plugin is
designed to be unopinionated and modular. What this means for us (the users)
is that we have to assemble various pieces to get the behavior we want.

                                             *lsp-zero-completion-keybindings*

When you enable `set_basic_mappings` in the function |lsp-zero.extend_cmp()|
lsp-zero creates the following keybindings.

    <Ctrl-y>: ~
        Confirms selection.

    <Ctrl-e>: ~
        Cancel completion.

    <Up>: ~
        Navigate to previous item on the list.

    <Down>: ~
        Navigate to the next item on the list.

    <Ctrl-p>: ~
        If the completion menu is visible, go to the previous item.
        Else, trigger completion menu.

    <Ctrl-n>: ~
        If the completion menu is visible, go to the next item.
        Else, trigger completion menu.

    <Ctrl-u>: ~
        Scroll up in the item's documentation.

    <Ctrl-d>: ~
        Scroll down in the item's documentation.

And when you enable `set_extra_mappings` it creates these.

    <Ctrl-f>: ~
        Go to the next placeholder in the snippet.

    <Ctrl-b>: ~
        Go to the previous placeholder in the snippet.

    <Tab>: ~
        Enables completion when the cursor is inside a word. If the completion
        menu is visible it will navigate to the next item in the list.

    <Shift-Tab>: ~
        When the completion menu is visible navigate to the previous
        item in the list.

==============================================================================
LSP                                                      *lsp-zero-lsp-config*

Language servers are configured and initialized using |lspconfig|.

lsp-zero adds some extra "capabilities" to lspconfig's defaults, they tell the
language server what features |nvim-cmp| adds to the editor.

Then it creates an autocommand on the event |LspAttach|. This autocommand will
be triggered every time a language server is attached to a buffer. Is where
all keybindings and commands are created.

If you were to do it all by yourself, the code would look like this.
>lua
  local lspconfig = require('lspconfig')
  local lsp_defaults = lspconfig.util.default_config

  lsp_defaults.capabilities = vim.tbl_deep_extend(
    'force',
    lsp_defaults.capabilities,
    require('cmp_nvim_lsp').default_capabilities()
  )

  vim.api.nvim_create_autocmd('LspAttach', {
    desc = 'LSP actions',
    callback = function(event)
      vim.keymap.set('n', 'K', '<cmd>lua vim.lsp.buf.hover()<cr>', {buffer = true})
      -- More keybindings and commands....
    end
  })

  lspconfig.tsserver.setup({})
  lspconfig.rust_analyzer.setup({})
<
                                                           *lsp-zero-commands*

LspZeroFormat {server} timeout={timeout}: ~
    Formats the current buffer or range. Under the hood lsp-zero is using the
    function |vim.lsp.buf.format()|.

    If the "bang" is provided formatting will be asynchronous
    (ex: `LspZeroFormat!`).

    If you provide the name of a language server as a first argument it will
    try to format only using that server. Otherwise, it will use every
    active language server with formatting capabilities.

    With the {timeout} parameter you can configure the time in milliseconds
    to wait for the response of the formatting requests.

LspZeroWorkspaceRemove: ~
    Remove the folder at path from the workspace folders.
    See |vim.lsp.buf.remove_workspace_folder()|.

LspZeroWorkspaceAdd: ~
    Add the folder at path to the workspace folders.
    See |vim.lsp.buf.add_workspace_folder()|.

LspZeroWorkspaceList: ~
    List workspace folders. See |vim.lsp.buf.list_workspace_folders()|.

LspZeroSetupServers [{server}]: ~
    It takes a space separated list of servers and configures them.
    It calls the function |lsp-zero.setup_servers()| under the hood.
    If the `bang` is provided the root dir of the language server
    will be the same as neovim. Note that this command for when you
    decide to handle the configuration of servers manually, it will
    only do something when `setup_servers_on_start` is disabled.

                                                        *lsp-zero-keybindings*

When a language server gets attached to a buffer you gain access to some
keybindings and commands. All of these are bound to a built-in function
so you can get more details using the `:help` command.

K: ~
    Displays hover information about the symbol under the cursor in a
    floating window. See |vim.lsp.buf.hover()|.

gd: ~
    Jumps to the definition of the symbol under the cursor.
    See |vim.lsp.buf.definition()|.

gD: ~
    Jumps to the declaration of the symbol under the cursor. Some servers
    don't implement this feature. See |vim.lsp.buf.declaration()|.

gi: ~
    Lists all the implementations for the symbol under the cursor in the
    quickfix window. See |vim.lsp.buf.implementation()|.

go: ~
    Jumps to the definition of the type of the symbol under the cursor.
    See |vim.lsp.buf.type_definition()|.

gr: ~
    Lists all the references to the symbol under the cursor in the quickfix
    window. See |vim.lsp.buf.references()|.

gs: ~
    Displays signature information about the symbol under the cursor in a
    floating window. See |vim.lsp.buf.signature_help()|. If a mapping
    already exists for this key this function is not bound.

<F2>: ~
    Renames all references to the symbol under the cursor.
    See |vim.lsp.buf.rename()|.

<F3>: ~
    Format a buffer using the LSP servers attached to it.
    See |vim.lsp.buf.rename()|.

<F4>: ~
    Selects a code action available at the current cursor position.
    See |vim.lsp.buf.code_action()|.

gl: ~
    Show diagnostic in a floating window. See |vim.diagnostic.open_float()|.

[d: ~
    Move to the previous diagnostic in the current buffer.
    See |vim.diagnostic.goto_prev()|.

]d: ~
    Move to the next diagnostic. See |vim.diagnostic.goto_next()|.

==============================================================================
Lua API                                                     *lsp-zero-lua-api*

                                                           *lsp-zero.preset()*

preset({opts}): ~
    Here is where you can add settings specific to lsp-zero.

    The {opts} table supports the following properties.

        *• float_border: (String, Optional) Defaults to `'rounded'`. Can have one
        of these: `'none'`, `'single'`, `'double'`, `'rounded'`, `'solid'` or
        `'shadow'`.

        *• set_signcolumn: (Boolean, Optional) Defaults to `true`. When set to
        `true` it will reserve a space in the gutter for the diagnostic signs.

        *• extend_lspconfig: (Boolean, Optional) Defaults to `true`. When set
        to `true` it will integrate nvim-cmp with lspconfig.
>lua
    local lsp = require('lsp-zero').preset({
      float_border = 'rounded',
      set_signcolumn = true,
      extend_lspconfig = true,
    })
<
                                                        *lsp-zero.on_attach()*

on_attach({callback}): ~
    Execute {callback} function every time a server is attached
    to a buffer.

    This is the place where you can create your own keybindings.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      local noremap = {buffer = bufnr}
      local bind = vim.keymap.set

      bind('n', '<leader>r', '<cmd>lua vim.lsp.buf.rename()<cr>', noremap)
      -- more code  ...
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                  *lsp-zero.default_keymaps()*

default_keymaps({opts}): ~
    Create the keybindings bound to built-in LSP functions.

    The {opts} table supports the same properties as `set_lsp_keymaps` and
    adds the following:

        • buffer: (Number, Optional) Defaults to 0. The "id" of an open buffer.
        If the number 0 is provided then the keymaps will be effective in the
        current buffer.

        • preserve_mappings: (Boolean, Optional) Defaults to `true`. When set to
        `true` lsp-zero will not override your existing keybindings.

        • exclude: (Table, Optional) List of valid keybindings. lsp-zero will
        preserve the behavior of these keybindings.

    The best place to add this function is the callback of
    |lsp-zero.on_attach()|.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                *lsp-zero.set_server_config()*

set_server_config({opts}): ~
    Share a configuration for all LSP servers configured with |lspconfig|.
    You can find more details about {opts} see |lspconfig-setup|.
>lua
    lsp.set_server_config({
      single_file_support = false,
    })
<
                                                        *lsp-zero.configure()*

configure({name}, {opts}): ~
    Useful when you need to pass some custom options to a specific
    language server. Takes the same options as `nvim-lspconfig`'s
    setup function. For more details go to |lspconfig-setup|.
>lua
    lsp.configure('tsserver', {
      single_file_support = false,
      on_attach = function(client, bufnr)
        print('hello tsserver')
      end
    })
<
                                                    *lsp-zero.setup_servers()*

setup_servers({list}): ~
    Will configure all the language servers you have on {list}.

    The {opts} table supports the following properties:

        • exclude: (Table, Optional). List of names of LSP servers you don't
        want to setup.

        • defer: (Boolean, Optional) Defaults to `false`. Delay the setup of
        language servers.

    Here is the basic usage.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
    When you mix this function with explict calls to `lspconfig`, order
    matters. |lsp-zero.setup_servers()| will not configure a server that was
    already initialized by lspconfig.

    If you plan to use the function |lsp-zero.installed()| to get an automatic
    setup is best that you place |lsp-zero.setup_servers()| after the calls to
    lspconfig.
>lua
    require('mason').setup({})
    require('mason-lspconfig').setup({
      ensure_installed = {'tsserver'}
    })

    local lsp = require('lsp-zero').preset({})

    require('lspconfig').tsserver.setup({
      single_file_support = false,
    })

    lsp.setup_servers(lsp.installed())
<
    In this case |lsp-zero.setup_servers()| will skip the setup of `tsserver`.

                                                    *lsp-zero.build_options()*

build_options({server}, {opts}): ~
    Returns all the parameters necessary to start a language using
    lspconfig's setup function. After calling this function
    you'll need to initialize the language server by other means.

    The {opts} table will be merged with the rest of the default
    options for {server}.

                                                     *lsp-zero.store_config()*

store_config({name}, {opts}): ~
    Saves the configuration options for a language server, so you can
    use it at a later time in a local config file.

                                                              *lsp-zero.use()*

use({name}, {opts}): ~
    For when you want full control of the servers you want to use in a
    particular project. It is meant to be called in project local config.

    Ideally, you would setup some default values for your servers
    in your neovim config using |lsp-zero.configure()|.
>lua
    -- init.lua

    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    lsp.configure('pyright', {
      single_file_support = false,
    })
<
    And then in your local config you can tweak the server options even more.
>lua
    -- local config

    local lsp = require('lsp-zero')

    lsp.use('pyright', {
      settings = {
        python = {
          analysis = {
            extraPaths = {'/path/to/my/dependencies'},
          }
        }
      }
    })
<
    Options from |lsp-zero.store_config()| will be merged with the ones on
    |lsp-zero.use()| and the server will be initialized.

    Note: lsp-zero does not execute files. It only provides utility functions.
    So to execute your "local config" you'll have to use another plugin.

                                                      *lsp-zero.nvim_lua_ls()*

nvim_lua_ls({opts}): ~
    Returns settings specific to Neovim for the lua language server, lua_ls.
    If you provide the {opts} table it'll merge it with the defaults,
    this way you can extend or change the values easily.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    require('lspconfig').lua_ls.setup(lsp.nvim_lua_ls())
<
                                                   *lsp-zero.format_on_save()*
format_on_save({opts}): ~
    Setup autoformat on save. This will to allow you to associate a language
    server with a list of filetypes.

    Keep in mind it's only meant to allow one LSP server per filetype,
    this is so the formatting is consistent.

    {opts} supports the following properties:

        • servers: (Table) Key/value pair list. On the left hand side you must
        specify the name of a language server. On the right hand side you must
        provide a list of filetypes, this can be any pattern supported
        by the |FileType| autocommand.

        • format_opts: (Table, Optional). These are the same options you can pass to
        |vim.lsp.buf.format()|.

    When you enable async formatting the only arguments in `format_opts` that
    will have any effect are `formatting_options` and `timeout_ms`, the rest
    will be ignored.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    lsp.format_on_save({
      servers = {
        ['rust_analyzer'] = {'rust'},
        ['tsserver'] = {'javascript', 'typescript'},
      }
    })

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
                                               *lsp-zero.buffer_autoformat()*

buffer_autoformat({client}, {bufnr}, {opts}): ~
    Format the current buffer using the active language servers.

    • {client}: (Table, Optional) if provided it must be a lua table with a
    `name` property or an instance of |vim.lsp.client|. If provided it will
    only use the LSP server associated with that client.

    *• {bufnr}: (Number, Optional) if provided it must be the id
    of an open buffer.

    • {opts}: (Table). These are the same options you can pass to
    |vim.lsp.buf.format()|.

>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
      lsp.buffer_autoformat()
    end)

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
                                               *lsp-zero.async_autoformat()*

async_autoformat({client}, {bufnr}, {opts}): ~
    Send a formatting request to {client}. After the getting the response
    from the client it will save the file (again).

    Here is how it works: when you save the file Neovim will write your
    changes without formatting. Then, lsp-zero will send a request to
    {client}, when it gets the response it will apply the formatting and
    save the file again.

    • {client}: (Table) It must be an instance of |vim.lsp.client|.

    • {bufnr}: (Number, Optional) if provided it must be the id of an open
    buffer.

    • {opts}: (Table, Optional). Supports the following properties:

        • formatting_options: Settings send to the language server. These
        are the same settings as the `formatting_options` argument in
        |vim.lsp.buf.format()|.

        • timeout_ms: (Number, Optional) Defaults to 10000. Time in
        milliseconds to ignore the current format request.

    Do not use this in the global `on_attach`, call this function
    with the specific language server you want to format with.

    Here is an example.
>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    require('lspconfig').tsserver.setup({
      on_attach = function(client, bufnr)
        lsp.async_autoformat(client, bufnr)
      end
    })

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'rust_analyzer'})
<
                                                   *lsp-zero.format_mapping()*
format_mapping({key}, {opts}): ~
    Configure {key} to format the current buffer.

    The idea here is that you associate a language server with a list of
    filetypes, so {key} can format the buffer using only one LSP server.

    {opts} supports the following properties:

        • servers: (Table) Key/value pair list. On the left hand side you must
        specify the name of a language server. On the right hand side you must
        provide a list of filetypes, this can be any pattern supported
        by the |FileType| autocommand.

        • format_opts: (Table). These are the same options you can pass to
        |vim.lsp.buf.format()|.

        • mode: (Table). The list of modes where the keybinding will be active.
        By default is set to `{'n', 'x'}`, which means normal mode and visual
        mode.

>lua
    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    lsp.format_mapping('gq', {
      servers = {
        ['rust_analyzer'] = {'rust'},
        ['tsserver'] = {'javascript', 'typescript'},
      }
    })

    -- Replace the language servers listed here
    -- with the ones you have installed
    lsp.setup_servers({'tsserver', 'rust_analyzer'})
<
                                                   *lsp-zero.set_sign_icons()*

set_sign_icons({opts}): ~
    Defines the sign icons that appear in the gutter.

    {opts} table supports these properties:

        • error: (String, Optional) Text for the error signs.

        • warn: (String, Optional) Text for the warning signs.

        • hint: (String, Optional) Text for the hint signs.

        • info: (String, Optional) Text for the information signs. >lua

    local lsp = require('lsp-zero')

    lsp.set_sign_icons({
      error = '✘',
      warn = '▲',
      hint = '⚑',
      info = '»'
    })
<
                                                        *lsp-zero.installed()*

installed(): ~
    Returns the list of language servers installed by |mason.nvim|. This
    function depends on the plugin |mason-lspconfig.nvim|, , so if you use
    this make sure to setup mason.nvim before lsp-zero.

    The common usecase for this function is to create an automatic setup of
    language servers when using lsp-zero and mason.nvim.
>lua
    require('mason').setup({})
    require('mason-lspconfig').setup({})

    local lsp = require('lsp-zero').preset({})

    lsp.extend_cmp()

    lsp.on_attach(function()
      lsp.default_keymaps({buffer = bufnr})
    end)

    lsp.setup_servers(lsp.installed())
<
    Note that the servers will not be configured immediately after installion.
    You'll need to restart Neovim after you install a server with mason.nvim.

    To get the list of servers quickly from command mode you can execute this
    command.
>lua
    :lua require('lsp-zero').installed()
<
                                                       *lsp-zero.new_server()*

new_server({opts}): ~
    lsp-zero will execute a user provided function to detect the root
    directory of the project when Neovim assigns the file type for a
    buffer. If the root directory is detected the LSP server will be
    attached to the file.

    This function does not depend on `lspconfig`, it's a thin wrapper
    around a Neovim function called |vim.lsp.start()|.

    {opts} supports every property |vim.lsp.start()| supports with
    a few changes:

        • filestypes: (Table) Can be list filetype names. This can be
        any pattern the `FileType` autocommand accepts.

        • root_dir: Can be a function, it'll be executed after Neovim
        assigns the file type for a buffer. If it returns a string
        that will be considered the root directory for the project.

    Other important properties are:

        • cmd: (Table) A lua table with the arguments necessary to start
        the language server.

        • name: (String) The name Neovim will assign to the client object.

        • on_attach: (Function) A function that will be executed after
        the language server gets attached to a buffer.

    Here is an example that starts the typescript language server on
    javascript and typescript, but only in a project that package.json
    in the current directory or any of its parent folders.
>lua
    local lsp = require('lsp-zero')

    lsp.extend_cmp()

    lsp.on_attach(function()
      lsp.default_keymaps({buffer = bufnr})
    end)

    lsp.new_server({
      name = 'tsserver',
      cmd = {'typescript-language-server', '--stdio'},
      filetypes = {'javascript', 'typescript'},
      root_dir = function()
        return lsp.dir.find_first({'package.json'})
      end
    })
<
                                                   *lsp-zero.dir.find_first()*

dir.find_first({list}): ~
    Checks the parent directories and returns the path to the first folder
    that has a file in {list}. Useful to detect the root directory.

    Note: search will stop once it gets to your "HOME" folder.

    {list} supports the following properties:

      • path: (String) The path from where it should start looking for
      the files in {list}.

      • buffer: (Boolean) When enabled use the path of the current buffer. >lua

    local lsp = require('lsp-zero')

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    require('lspconfig').lua_ls.setup({
      root_dir = function()
        --- project root will be the first directory that has
        --- either .luarc.json or .stylua.toml
        return lsp.dir.find_first({'.luarc.json', '.stylua.toml'})
      end
    })
<
                                                     *lsp-zero.dir.find_all()*

dir.find_all({list}): ~
    Checks the parent directories and returns the path to the first folder
    that has all the files in {list}. Useful to detect the root directory.

    Note: search will stop once it gets to your "HOME" folder.

    {list} supports the following properties:

      • path: (String, Optional) The path from where it should start looking
      for the files in {list}.

      • buffer: (Boolean, Optional) When enabled use the path of the current
      buffer. >lua

    local lsp = require('lsp-zero')

    lsp.extend_cmp()

    lsp.on_attach(function(client, bufnr)
      lsp.default_keymaps({buffer = bufnr})
    end)

    require('lspconfig').lua_ls.setup({
      root_dir = function()
        --- project root will be the first directory that has
        --- either .luarc.json or .stylua.toml
        return lsp.dir.find_first({'.luarc.json', '.stylua.toml'})
      end
    })
<
                                                       *lsp-zero.cmp_action()*

cmp_action(): ~
    Returns methods meant to be used as mappings for |nvim-cmp|.

    These are the supported methods:

        • tab_complete: ~
            Enables completion when the cursor is inside a word. If the
            completion menu is visible it will navigate to the next item in
            the list. If the line is empty it uses the fallback.

        • select_prev_or_fallback: ~
            If the completion menu is visible navigate to the
            previous item in the list. Else, uses the fallback.

        • toggle_completion: ~
            If the completion menu is visible it cancels the process.
            Else, it triggers the completion menu.

        • luasnip_jump_forward: ~
            Go to the next placeholder in the snippet.

        • luasnip_jump_backward: ~
            Go to the previous placeholder in the snippet.

        • luasnip_next: ~
            If completion menu is visible it will navigate to the item in the
            list. If the cursor can jump to a snippet placeholder, it moves to
            it. Else, it uses the fallback.

        • luasnip_next_or_expand: ~
            If completion menu is visible it will navigate to the item in the
            list. If cursor is on top of the trigger of a snippet it'll expand
            it. If the cursor can jump to a snippet placeholder, it moves to
            it. Else, it uses the fallback.

        • luasnip_supertab: ~
            If the completion menu is visible it will navigate to the
            next item in the list. If cursor is on top of the trigger
            of a snippet it'll expand it. If the cursor can jump to a
            snippet placeholder, it moves to it. If the cursor is in
            the middle of a word that doesn't trigger a snippet it
            displays the completion menu. Else, it uses the fallback.

        • luasnip_shift_supertab: ~
            If the completion menu is visible it'll navigate to previous item
            in the list. If the cursor can navigate to a previous snippet
            placeholder, it moves to it. Else, it uses the fallback.

    Quick note: "the fallback" is the default behavior of the key
    you assign to a method.

                                                       *lsp-zero.extend_cmp()*

extend_cmp({opts}): ~
    In case you don't want to use lsp-zero to actually setup any LSP servers,
    or want to lazy load nvim-cmp, you can use .extend_cmp to setup nvim-cmp.

    When you used it is assumed you want a "minimal" configuration.
    Meaning that if you call it without {opts} it will use the same
    config the minimal preset uses in the setting manage_nvim_cmp.

    {opts} supports the same properties `manage_nvim_cmp` has.
>lua
    require('lsp-zero').extend_cmp()

    local cmp = require('cmp')
    local cmp_action = require('lsp-zero').cmp_action()

    cmp.setup({
      sources = {
        {name = 'nvim_lsp'},
      },
      window = {
        completion = cmp.config.window.bordered(),
        documentation = cmp.config.window.bordered(),
      },
      mapping = {
        ['<C-Space>'] = cmp.mapping.complete(),
        ['<C-y>'] = cmp.mapping.confirm({select = true}),
        ['<C-u>'] = cmp.mapping.scroll_docs(-4),
        ['<C-d>'] = cmp.mapping.scroll_docs(4),
        ['<C-f>'] = cmp_action.luasnip_jump_forward(),
        ['<C-b>'] = cmp_action.luasnip_jump_backward(),
      }
    })
<
                                                   *lsp-zero.omnifunc.setup()*

.omnifunc.setup({opts}): ~
    Configure the behavior of Neovim's completion mechanism. If for some
    reason you refuse to install nvim-cmp you can use this function to
    make the built-in completions more user friendly.

    {opts} supports the following properties:

      • autocomplete: (String, Optional) Defaults to `false`. When enabled it
      triggers the completion menu if the character under the cursor matches
      `opts.keyword_pattern`. Completions will be disabled when you are
      recording a macro. Do note, the implementation here is extremely simple,
      there isn't any kind of optimizations in place. Is literally like
      pressing `<Ctrl-x><Ctrl-o>` after you insert a character in a word.

      • tabcomplete: (Boolean, Optional) Defaults to `false`. When enabled
      `<Tab>` will trigger the completion menu if the cursor is in the middle
      of a word. When the completion menu is visible it will navigate to the
      next item in the menu. If there is a blank character under the cursor it
      inserts a `Tab` character. `<Shift-Tab>` will navigate to the previous
      item in the menu, and if the menu is not visible it'll insert a `Tab`
      character.

      • trigger: (String, Optional) It must be a valid keyboard shortcut. This
      will be used as a keybinding to trigger the completion menu manually.
      Actually, it will be able to toggle the completion menu. You'll be able
      to show and hide the menu with the same keybinding.

      • use_fallback: (Boolean, Optional) Defaults to `false`. When enabled
      lsp-zero will try to complete using the words in the current buffer. And
      when an LSP server is attached to the buffer, it will replace the
      fallback completion with the LSP completions.

      • keyword_pattern: (String, Optional) Defaults to `"[[:keyword:]]"`.
      Regex pattern used by the autocomplete implementation.

      • update_on_delete: (Boolean, Optional) Defaults to `false`. Turns out
      Neovim will hide the completion menu when you delete a character, so
      when you enable this option lsp-zero will trigger the menu again after
      you press `<backspace>`. This will only happen with LSP completions, the
      fallback completion updates automatically (again, this is Neovim's
      default behavior). This option is disabled by default because it
      requires lsp-zero to bind the backspace key, which may cause conflicts
      with other plugins.

      • select_behavior: (String, Optional) Defaults to `"select"`. Configures
      what happens when you select an item in the completion menu. When the
      value is `"insert"` Neovim will insert the text of the item in the
      buffer. When the value is `"select"` nothing happens, Neovim will only
      highlight the item in the menu, the text in the buffer will not change.

      • preselect: (Boolean, Optional) Defaults to `true`. When enabled the
      first item in the completion menu will be selected automatically.

      • verbose: (Boolean, Optional) Defaults to `false`. When enabled Neovim
      will show the state of the completion in message area.

      • mapping: (Table, Optional) Defaults to an empty table. With this you
      can configure the keybinding for common actions.

          • confirm: Accept the selected completion item.

          *• abort: Cancel current completion.

          *• next_item: Navigate to next item in the completion menu.

          • prev_item: Navigate to previous item in the completion menu.

    You can configure a basic "tab completion" behavior using these settings.
>lua
    local lsp = require('lsp-zero')

    lsp.omnifunc.setup({
      tabcomplete = true,
      use_fallback = true,
      update_on_delete = true,
    })
<
    And here is an example for autocomplete.
>lua
    local lsp = require('lsp-zero')

    lsp.omnifunc.setup({
      autocomplete = true,
      use_fallback = true,
      update_on_delete = true,
      trigger = '<C-Space>',
    })
<
==============================================================================
Guides                                                       *lsp-zero-guides*

                                             *lsp-zero-guide:ensure-installed*

Automatic installation of LSP servers

We can use the module `mason-lspconfig` to list the LSP servers we want to
install using |mason.nvim|. Here is an example.
>lua
  require('mason').setup({})
  require('mason-lspconfig').setup({
    ensure_installed = {
      -- Replace these with whatever servers you want to install
      'tsserver',
      'eslint',
      'rust_analyzer',
    }
  })

  local lsp = require('lsp-zero').preset({})

  lsp.extend_cmp()

  lsp.on_attach(function(client, bufnr)
    lsp.default_keymaps({buffer = bufnr})
  end)

  lsp.setup_servers(lsp.installed())
<
Notice here we use the function |lsp-zero.installed()|, we do that to get the
complete list of installed servers. If you install more LSP servers in the
future you don't have to add it in the function |lsp-zero.setup_servers()|.

If you need to setup a set of LSP servers manually, you can use the property
`exclude` in the second argument of |lsp-zero.setup_servers()|.
>lua
  lsp.setup_servers(lsp.installed(), {
    exclude = {'rust_analyzer', 'jdtls'}
  })
<
==============================================================================
Version                                                     *lsp-zero-version*

Current version: `v3-dev`

This is a development branch, breaking changes can happen. 

The code on this version requires Neovim v0.8 or greater. If you need support
for Neovim v0.7 or lower use the `v1.x` branch of lsp.zero.

==============================================================================
Support                                                    *lsp-zero-donation*

If you find this tool useful and want to support my efforts, consider
leaving a tip in https://www.buymeacoffee.com/vonheikemen

vim:tw=78:ft=help:norl:
